#generalconcepts 

Loosely related project: [Write a system call by Stephen Brennan](https://brennan.io/2016/11/14/kernel-dev-ep3/)

# [Varun Kouda: Linkedin - Notes on interrupts](https://www.linkedin.com/posts/varun-kouda-522a23165_hand-written-notes-on-interrupts-activity-7064281048485957632-6-oB?utm_source=share&utm_medium=member_desktop)

An interrupt is an event or exception, generated by either hardware or software, for which the CPU must stop its current activity and perform a service or run code related to the event.

## Asynchronous: Hardware Interrupts
Typically raised by a hardware device (whether internal or external) connected to the MCU.
These events are generated at arbitrary (or random) times with respect to CPU clock signals. 

Examples of internal hardware scenarios:
+ A communication protocol module received a new byte of data
+ Timer module completed the required time
+ ADC module finished ADC conversion

Procedure:
+ Device issues interrupt request to CPU
+ CPU suspends current task
+ CPU executes ISR (Interrupt Service Routine) to service the device
+ CPU resumes previous task

## Synchronous: Exceptions
These are produced by the CPU control unit while executing instructions, upon detecting an error or exception in a given instruction.
The CPU only issues these after execution of an instruction has been terminated.

When an exception occurs, the processor writes a specific value to a certain register in memory. This value is used to determine the exception classification/grouping. This value is the address of the instruction that caused the exception to occur.

Divided into 3 groups:
### 1. Faults
+ Saved value in register is the address of the instruction that caused the fault.
+ Generally correctable, able to restore program with no loss of continuity
+ When the exception handler can correct the condition that caused the exception, the instruction that caused the fault can be resumed
+ Common examples: Divide error, Invalid opcode, floating point error.

### 2. Traps
+ Saved value in register is address of the instruction which **should be executed after the trap**
+ Main use is in debugging
+ The interrupt signal is used to notify the debugger that a specific instruction has been executed
+ The debugger provides data to be examined by the user/developer
+ The user may ask that execution of the program resumes from the next instruction
+ Examples include a breakpoint or overflow

### 3. Aborts
+ Serious error occurred such as hardware failure
+ Control unit may be unable to store the location of the broken instruction to the register
+ The interrupt signal is sent by the control unit, this is an emergency signal used to switch control to the necessary exception handler.
+ Examples include double faults or machine-check exceptions

## Software interrupt
It's possible to trigger exceptions/interrupts using software.

## Interrupt Service Routine (ISR/ESR)
A software routine that is invoked by the CPU in response to a interrupt or exception. When an interrupt/exception occurs, the CPU will jump to execute the ISR. 

It's necessary for an ISR to run quickly to prevent slowdown of the device. An ISRs address is determined when compiling the application and is stored in a fixed location in flash memory (ROM).

+ ISR address is called a vector
+ All vectors are grouped in a vector table
+ The vector table location is known and can either be fixed or mapped.
+ ISR functions have no passed arguments and can never return a value.

## Interrupt handling

1. CPU finished with its current instruction and saves the address of the next instruction on the stack
2. CPU jumps to the vector table (in memory) which directs the CPU to the address of the necessary ISR
3. CPU begins executing the ISR until completion which leads to `RETI` (return from interrupt)
4. After executing `RETI`, the CPU returns to the task it was working on before being interrupted by obtaining the necessary PC address from the top of the stack. It then executes from that address.

### Vectored Arbitration System

## Interrupt masking and pending

2 types of interrupt masking:
### 1. Maskable Interrupt
+ Can be enabled or disabled
+ Each interrupt has a 'flag bit' to indicate the event happened
+ Each has an 'enable bit' to enable or disable the interrupt

So the logic is:
`if flag bit = 1 and enable bit = 0` then the CPU was not interrupted
`if flag bit =1 and enable bit = 1` then the CPU was interrupted

### 2. Non-maskable interrupt
+ Can't be disabled and must  be served
+ Each has a flag bit to indicate the event happened
+ An example is the reset interrupt

### Interrupt pending
Interrupt handlers associate priorities with interrupts, this priority will determine which interrupt should be handled first where multiple interrupts are called at the same time.

Interrupts will be handled in priority order - highest to lowest - with lower priority interrupts remaining in a 'pending state' until higher priority interrupts have been serviced.

Priority is based on importance and urgency of the interrupt.

## Polling vs Interrupts
Where interrupts rely on notification and interruption, Polling is where conditions and statuses are continuously checked in order to then be served when a specific condition is met. A micro-controller would constantly check device statuses, serving them upon a specific condition being met. 

Interrupts are a hardware mechanism where Polling is a protocol. 

Interrupts are typically more preferable as the device (whether a CPU or micro-controller) has the ability to perform other tasks while waiting for interrupt requests, if necessary they can also ignore these requests which saves time and permits efficiency. 

Polling is mostly efficient if events rapidly occur at a high rate though this method utilises CPU time even if there is no pending request. 

## Priority
Solution to decide which interrupt(s) should be serviced first when several interrupts have been requested. Interrupt priority is based on importance to the system therefore higher priority interrupts are serviced first.

In micro-controllers, interrupts may be fixed by the hardware and thus can't be changed via software (known as Traps). Though they may have the ability to be changed by the software (through pre-configs and runtime).

## Controller
An interrupt controller (usually a PIC or NVIC) controls behaviour of interrupts including enabling/disabling, setting priority and selecting interrupt source.

PIC: Programmable Interrupt Controller
NVIC: Nested Vector Interrupt Controller

### Handling 2 interrupts with the same priority

#### Round Robin
Interrupts handled on an alternating basis. One interrupt will be handled for a few cycles, then the CPU will switch to the other until both are complete. This ensures both are serviced in a timely manner. 

#### First come, First Served (Priority Queuing)
Whichever interrupt came first is handled first.

Sometimes, interrupts may be temporarily masked to ensure that the current interrupt is fully handled before working on another interrupt of the same priority.

Round robin is often considered to be more fair as it ensures both interrupts are serviced within a reasonable time-frame.

### Nesting
Situation where an interrupt occurs while the CPU is already running another interrupt.
Nesting is a default behaviour of interrupts.

#### Interrupt Preemption
In cases where a high priority interrupt runs while the CPU is running a low priority interrupt, the CPU saves the context of the lower ISR and immediately work on the higher ISR. Once the higher interrupt is complete, the CPU returns to the lower ISR and continues from where it was.

If the opposite occurs (low prio interrupt occurs during a high prio running), then the lower priority interrupt is either masked or preempted until the higher interrupt is finished. Which is a common approach.