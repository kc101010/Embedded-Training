
#communicationprot 

# [Texas Instruments: Understanding the I2C Bus](https://www.ti.com/lit/an/slva704/slva704.pdf)

## Core points/abstract
+ I2C bus is popular and powerful
+ Used for comms between a master(s) and slave(s) devices (may be single or many)
+ Can be used by many peripherals and connected by only 2 wires (thus is simple to configure/set-up yet works with many other systems)

## Electrical characteristics
Uses an open-drain/open-collector with input buffer on the same line. Allows one data line to be used for bi-directional data flow.

### Open-drain
Output which can either pull the bus down to a voltage or 'release' the bus and let it be pulled by a pull-up resistor.

If the bus were released by the master or slave, the pull-up resistor is then responsible for pulling the bus voltage up to the power rail. As no device may force a high on a line, the bus will never have communication issues such as a short where 2 different devices transmits high and low at the same time. 

I2C requires a multi-environment master to halt communications if the line is low and pulled down by another device as another device is clearly using the bus. This type of freedom is not allowed in push-pull interfaces, thus this makes I2C beneficial.

A device can only pull the bus line low (provide a short to ground) or release the bus line (high impedance to ground), allowing the pull-up resistor to raise the voltage. This is important as no device may hold the bus high which allows for the bidirectional communication.

## General i2c operation
This bus is a standard bi-directional interface which uses a controller (aka master) to communicate with slave devices. A slave may not transmit data unless it has been addressed by the master.

Each device on the bus has a specific device address to differentiate from others on the same bus. Many slave devices will require startup configuration to denote device behaviour which is typically achieved when the master accesses the slaves internal register maps, which have unique register addresses. A device can have one or many registers which may store, write or read data.

The physical i2c interface consists of the serial clock (SCL) and serial data (SDA) lines. Both lines must be connected to ground through a pull-up resistor. Pull-up resistor size is determined by capacitance amount on the i2c lines. 

Data transfer can only start when the bus is idle, which is when both SDA and SCL lines are high after a STOP condition.

General procedure for a master accessing a slave:

**Master wants to send data to slave**
1. Master transmitter sends START condition and addresses slave receiver
2. Master transmitter sends data to slave-receiver
3. Master transmitter terminates transfer with a STOP condition

**Master wants to read/recv data from slave**
1. Master receiver sends START condition and addresses slave transmitter
2. Master receiver sends requested register which should be read to slave transmitter
3. Master receiver receives data from slave transmitter
4. Master receiver terminates transfer with STOP condition

### START & STOP conditions
Communication with a device is initiated after a Master sends a START condition and is terminated after the Master sends a STOP condition.

A high-to-low transition on the SDA line while SCL is high represents a START condition.

A low-to-high transition on SDA while SCL is high represents a STOP condition.

A repeated START is similar to the typical START and is used instead of a repeating STOP then START. It looks almost identical to the START but differes as it occurs before a STOP when the bus isn't idle. 

This is useful for when the master wishes to start a new communication without letting the bus go idle with the next STOP condition. In multi master environments, this means the master has a chance of losing control of the bus to another master.

----

# [ How I2C Communication Works and How To Use It with Arduino](https://youtu.be/6IAkYpmA1DQ)

Popular as it can be easily implemented (requires only 2 wires with up to 128 devices when using 7-bit addressing). So many devices can be implemented as they are simply connected to the 2 wires, the I2C bus can then interact with them by simply using the specific device address. 

I2C is typically used in a master-slave setting (though there are many more possible configs).

SCL - Serial Clock
+ Clock signal syncs data transfer between devices on the bus, generated by master device 

SDA - Serial Data
+ Carries data

Both SDA and SCL are open-drain, they require pull-up resistors so the lines are high as the devices on the bus are active-low. 

Communication typically sees the transfer of the device address, internal register address as well as data. Between these variables, start, stop and acknowledgement bits are placed. The described variables can be represented as sequences of data, the video example represented in 8 bit sequencing. 

The acknowledge bits are used to confirm that data reached its destination, the first 7 bits of a sequence represent the address with the final 8th bit often representing a read/write signal.

A typical data transfer is :

Start bit
Device/Slave Address
Ack bit
Internal register Address
Ack bit
Data
Ack bit
Stop bit

So I2C is a system of timing and data transfer allowing for communication between various devices within a larger system or circuit.

## Physical arduino example

GY-80 breakout and GY-521 breakout, data from 8 different sensors using I2C.
`i2c_scanner` sketch on Arduino examples.
Uses Wire library to transmit and read data.

# [ I2C Introduction – Part 1 (Basics)](https://embetronicx.com/tutorials/tech_devices/i2c_1/)

2 wire interface to connect low-speed devices like MCUs, EEPROMS, A/D & D/A converters, I/O Interfaces and other similar peripherals. It was originally created by Phillips.

Popular due to its simpicity. Simple to implement even on cheap microcontrollers, just need 2 free I/O pins and some simple i2c routines to send/receive commands.

Tranferring to and from the master device is serial and split into 8-bit packets.

4 operating speed categories for bidirectional data transfer
+ Standard Mode (Sm) : bit rate up to 100 kbit/s
+ Fast Mode (Fm) : bit rate up to 400 kbit/s
+ Fast-mode Plus (Fm+) : bit rate up to 1 Mbit/s
+ High-speed Mode (Hs-mode) : bit rate up to 3.4 Mbit/s
+ Ultra-fast mode (UFm) : bit rate up to 5 Mbit/s

## The interface
Uses only 2 wires:
+ SCL - serial clock
+ SDA - serial data

Both need to be pulled up (w/ resistor) to +Vdd.

## Addressing
Basic communication uses transfers of 8 bits (or a single byte). Each slave device has a 7-bit address that must be unique on the bus. Some devices have fixed addresses while others have a few address lines that determine the lower bits of the address. It is possible that some devices may use a 10 bit address. 

The 7 bit address uses bits 7 to 1 with bit 0 used to signal a device read or write operation. If bit 0 is set to 1 then the master will read from the slave. It's not necessary for the master to have an address as it generates the clock and addresses slave devices individually. 


## Protocol
In a normal state, both lines are high, communication is initiated by  the master device. It first sets the Start condition (S) followed by the slave address. If bit 0 of the address byte was set to 0, the master will write to the slave. Otherwise, the next byte is read from the slave. Once all bytes are read/written, the master sets the Stop condition which signals to other devices that communication has ended and the bus is now available for use. 

![[i2c-protocol.webp]]

Most I2C devices support repeat start conditions. Meaning the master can repeat the start condition before communication ends and change modes with the current slave.

## Conclusion
+ Widely-used
+ Simple to implement
+ Can be used with any microcontroller
+ The specification is flexible

# [ I2C Protocol Introduction – Part 2 (Advanced Topics)](https://embetronicx.com/tutorials/tech_devices/i2c_2/)

Each device has the possibility of being a transmitter, a receiver or both. Some devices are masters which generate bus clocks and iniate communication on the bus. Others are slaves which respond to commands based on the bus. Master devices typically consist of Microcontrollers etc where Slaves are typically peripheral/hardware.

## Terminology
+ Transmitter: device that transmits data to the bus
+ Receiver: device that receives data from the bus
+ Master: device that generates the clock, starts/stops communication, sends commands 
+ Slave: device that listens to the bus and addressed by the master
+ Multi-master: It's possible for I2C to use more than 1 master, all can send commands
+ Arbitration: A process to determine which master can use the bus when more masters need to use it
+ Synchronisation: Process to synchronize clocks of 2 or more devices

## Protocol

### Bus signals
Both singals are bidirectional, and are connected to a positive power supply voltage via resistors. This means when the bus is free, both lines are high and activating the line means pulling it down.  All bus devices must have open-collector or open-drain pins.

The number of possible devices on a single bus is almost unlimited with the only requirement being that bus capacitance doesn't exceed 400 pF (as logical 1 level depends on the supply voltage, there is no standard bus voltage).

### Serial Data Transfer
For each clock pulse, 1 bit of data is transferred. The SDA signal can only change when the SCL signal is low thus when the clock is high, the data should be stable. 

#### Start and Stop Condition
Each command initiated by the master starts with a *START* condition and ends with a *STOP* condition. For both conditions, SCL must be high. 

A transition of high to low on the SDA is considered a *START*.
A transition of low to high is considered a *STOP*.

After the *START*, the bus is considered to be busy. It can only be used by another master after the next *STOP*. After the *START*, it's possible for the master to generate a repeated *START* condition which is equivalent to a normal start (and usually followed by the slave address).

If a microcontroller has dedicated I2C hardware then it can easily detect changes on the bus and even behave as a slave. If the communication is implemented in software then the bus singals must be sampled at least 2 times per clock cycle in order to detect all necessary changes.

## Data Transfer
Transferred in 8-bit packets and there is no limitation on the number of bytes though each byte must be followed by acknowledge bit. (Which singals whether the device is ready to proceed with the next byte). 

For all data bits (including the Ack), it is necessary for the master to generate clock pulses. If the slave doesn't acknowledge the transfer, this means there is no more data or the device isn't yet ready for the transfer. In this case the Master must either generate a *STOP* or repeated *START* condition. 

### Synchronisation
Each master device must generate its own clock signal where data can change only when the clock is low. In order to provide successful bus arbitration, it's necessary to have a synchronized clock. 

When a master pulls the clock low, it stays low until all masters put the clock into a high state. Similarly, the clock is high until the first master pulls it low. This way, Master devices can simply sync their clocks by watching the SCL signal. 

### Clock Stretching
While the clock master determines the clock speed, there are sometimes where an I2C slave is unable to properly work with masters given clock speed and needs to slow down. This is known as clock stretching.

A slave has the ability to hold down the clock if it needs to reduce bus speed. The master must read back the clock signal after releasing it to a high state and wait until the line has gone high. 

### Arbitration
A typical data transfer on the I2C bus means only one master can be active. If 2 masters start the line at the same time then arbitration is used to determine which master continues with their command.

Arbitration is performed on the SDA signal while SCL is high. Each master checks whehter the SDA signal on the bus matches the generated SDA signal. If the SDA signal on the bus is low but should be high, then this specific master has lost the arbitration and will not continue. Master devices which have lost arbitration can generate SCL pulses until the byte ends, they must then release the bus and enter slave mode.

It's possible for the arbitration procedure to continue until all data is transferred therefore in a multi-master system, each master needs to monitor the bus for collisions and react as expected.

### Clock synchronisation and Handshaking
Slaves which need time to process the received byte or aren't prepared to send the next byte have the ability to pull the clock low which signals that the master should wait. When the clock is released, the master can then proceed with the next byte. 

# [ I2C Client Linux Device Driver – Linux Device Driver Tutorial Part 37](https://embetronicx.com/tutorials/linux/device-drivers/i2c-linux-device-driver-using-raspberry-pi/#Data_in_SSD1306_OLED)

# [ How to use SSD1306 128x64 OLED Display I2C with Arduino code](https://youtu.be/UmYiHTOz-5k)


**Arduino layout**
SDA to A4
SCL to A5
Vcc is 3.3v/5v
GND to GND


SSD1306 address is 0x3C, another possible address is 0x3D. Based on the Arduino alarm code, I can likely use 0x3C.

Video isn't very useful for code-writing but good for setup etc. 